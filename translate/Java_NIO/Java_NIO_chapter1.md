# 第一章	引言

​	让我们先谈谈 **I/O** ，你肯定以为看错书了，这不是一本说New **I/O**的书嘛，**I/O**的确不是很吸引人的话题，但是确实是一个非常重要的基础。大多数程序员都认为**I/O**是核心内容，但是并不是很方便直接使用，如果使用不当容易产生一些难缠的问题。下面这些内容，能教你如何平滑的操作数据流。

​	面向对象设计都是关于封装设计的。封装是一个非常好的概念：区分职责，隐藏了具体实现的细节，还提升了复用性。这种区分和封装是为了应用在程序员，同样也适用于代码。你可能是一个技术纯熟的Java码农，写出非常牛逼的对象，做些牛逼的事情，但是你几乎完全忽视了Java **I/O**的一些基础概念。这一章节，为了让你更好的理解**I/O**涉及到的所有操作，我们暂时违反封装性，去看看**I/O**底层的实现细节。

## 1.1 I/O vs CPU

​	大多数程序员都幻想自己是软件艺术家，用一些措施比如重构，压缩使用的字节数等来完善对象。这些事情毋庸置疑是非常重要的，有意思的是，上面这些优化手段增加的效率很容易就被**I/O**的低效所拖累。换句话说， 执行**I/O**通常比执行内存处理数据要大几个数量级。许多程序员只关注他们的代码如何处理数据，对于数据存储和获取等环境问题却漠不关心。

​	**Table 1-1** 下面这个表格列举了执行磁盘读写数据任务的不同阶段的时间对比。第一列代表处理单位数据所花费的平均时间，第二列代表从磁盘读写单位数据花费的时间，第三列代表每秒可以处理的数据总数，也就是吞吐量。第四列代表吞吐量在前两列变量的变化所带来的增长率。（可以类比为做实验的控制变量法，保持一个变量不变，改变其他变量，再对所得的实验结果进行统计）。注：第一行数据为benchmark数据，后面计算都是以第一行数据为基准，包括增长率的计算。

<center><strong>Table 1-1</strong> 吞吐率对比，处理时间 <strong>vs</strong> IO时间</center>

| 处理时间（ms) | I/O时间（ms) | 吞吐率（数据单元/s） |    增长率（%）    |
| :-----------: | :----------: | :------------------: | :---------------: |
|       5       |     100      |         9.52         | 基准（benchmark） |
|      2.5      |     100      |         9.76         |       2.44        |
|       1       |     100      |         9.9          |       3.96        |
|       5       |      90      |        10.53         |       10.53       |
|       5       |      75      |         12.5         |       31.25       |
|       5       |      50      |        18.18         |       90.91       |
|       5       |      20      |          40          |        320        |
|       5       |      10      |        66.67         |        600        |

​	前三列展示了处理数据这个步骤给吞吐量带来的效率提升的比例，单位数据的处理时间缩短一半仅仅给吞吐量带来了2.2%的提升。另一方面，减少**I/O**的10%延迟就增加了9.7%的吞吐量的增加，当你看到每个单元进行I / O所花费的时间比处理时间大20倍时，**I/O**时间缩短一半使吞吐量增加了近一倍之多就不会感到惊讶了。

​	这些数据都是随机的，现实中的情况并非如此简单，不过从另一方面也表明了相对时间的大小。正如你所看到的，**I/O**基本上是应用性能的限制因素，而不是处理速度。程序员喜欢去调整他们的代码，但是**I/O**性能上的调整往往事后才被想起来，或者说完全被忽视了。其实真的很可惜，因为只需要在提高**I/O**性能方面很小的投入就能产生很大的效率的提升(**原文：substantial dividends=大量红利**)。

​	

## 1.2 不再是CPU的锅

​	某种程度上来说，Java程序员优化代码执行效率却忽略了**I/O**其实是情有可原的。在Java早期时候，JVM在解析字节码很少会进行运行时的优化，这意味着Java运行时明显比本地编译的机器码慢，所以对于操作系统的**I/O**并没有太多需求。

​	但是后期Java在运行时的优化有了巨大的进步，当代JVM运行字节码的速度已经接近本地编译的机器码，由于动态运行时的优化，有的甚至会更快。这意味着Java应用不再是受制于CPU(花费大量时间执行代码)，更多的是受制于**I/O**(等待数据传输)。

​	在大多数情况下，从某种意义上来说，其实是由于操作系统无法快速传递数据来一直保持忙碌状态，Java应用程序并未真正受I / O限制。相反，JVM并没有一直进行有效的I / O操作。在操作系统和Java中基于流的**I/O**模型是不兼容的，操作系统借助于直接内存访问(DMA)方式来移动大块数据，而JVM的**I/O**类通过字节或者文本行的碎片形式来操作数据。这就意味着操作系统传输全部数据，然后java.io的流类型花费大量时间来将全部数据分割成小的碎片数据，还需要在不同的对象之间复制碎片数据。操作系统想一次性传输大量的数据，而java.io类想处理小批量的数据。NIO解决了上述的矛盾，可以更轻松的处理大量数据的传输便于直接使用ByteBuffer 对象来处理数据。(**原文使用了truck，这里翻译为大量的，更易理解**)

​	这并不是说利用传统的**I/O**模型不可能实现移动大量数据，恰恰相反，过去可以，当然现在也仍然可以实现。如果坚持使用基于数组的读写方法(read() 和write())，那么RandomAccessFile类会特别有效。即使这些方法至少保存了一份缓冲的复制，但是十分接近于底层的系统调用了。

​	就像**Table 1-1**说明的那样，如果发现代码花费大量时间在等待**I/O**处理，是时候提高**I/O**性能，否则你那些精致编写的代码可能在大多数时间都是空闲的了。

## 1.3 了解一下新内容

## 1.4 I/O的概念

### 1.4.1 缓冲处理

#### 1.4.1.1 Scatter/gather

### 1.4.2 虚拟内存

### 1.4.3 内存分页

### 1.4.4 文件I/O

​	