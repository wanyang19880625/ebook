# 第一章	引言

​	让我们先谈谈 **I/O** ，你肯定以为看错书了，这不是一本说New **I/O**的书嘛，**I/O**的确不是很吸引人的话题，但是确实是一个非常重要的基础。大多数程序员都认为**I/O**是核心内容，但是并不是很方便直接使用，如果使用不当容易产生一些难缠的问题。下面这些内容，能教你如何平滑的操作数据流。

​	面向对象设计都是关于封装设计的。封装是一个非常好的概念：区分职责，隐藏了具体实现的细节，还提升了复用性。这种区分和封装是为了应用在程序员，同样也适用于代码。你可能是一个技术纯熟的Java码农，写出非常牛逼的对象，做些牛逼的事情，但是你几乎完全忽视了Java **I/O**的一些基础概念。这一章节，为了让你更好的理解**I/O**涉及到的所有操作，我们暂时违反封装性，去看看**I/O**底层的实现细节。

## 1.1 I/O vs CPU

​	大多数程序员都幻想自己是软件艺术家，用一些措施比如重构，压缩使用的字节数等来完善对象。这些事情毋庸置疑是非常重要的，有意思的是，上面这些优化手段增加的效率很容易就被**I/O**的低效所拖累。换句话说， 执行**I/O**通常比执行内存处理数据要大几个数量级。许多程序员只关注他们的代码如何处理数据，对于数据存储和获取等环境问题却漠不关心。

​	下面这个表格列举了执行磁盘读写数据任务的不同阶段的时间对比。第一列代表处理单位数据所花费的平均时间，第二列代表从磁盘读写单位数据花费的时间，第三列代表每秒可以处理的数据总数，也就是吞吐量。第四列代表吞吐量在前两列变量的变化所带来的增长率。（可以类比为做实验的控制变量法，保持一个变量不变，改变其他变量，再对所得的实验结果进行统计）。

​	前三列展示了处理数据这个步骤给吞吐量带来的效率提升的比例，单位数据的处理时间缩短一半仅仅给吞吐量带来了2.2%的提升。另一方面，减少**I/O**的10%延迟就增加了9.7%的吞吐量的增加，当你看到每个单元进行I / O所花费的时间比处理时间大20倍时，**I/O**时间缩短一半使吞吐量增加了近一倍之多就不会感到惊讶了。

​	这些数据都是随机的，现实中的情况并非如此简单，不过从另一方面也表明了相对时间的大小。正如你所看到的，**I/O**基本上是应用性能的限制因素，而不是处理速度。程序员喜欢去调整他们的代码，但是**I/O**性能上的调整往往事后才被想起来，或者说完全被忽视了。其实真的很可惜，因为只需要在提高**I/O**性能方面很小的投入就能产生很大的效率的提升(**原文：substantial dividends=大量红利**)。

​	

## 1.2 不再是CPU的锅

## 1.3 了解一下新内容

## 1.4 I/O的概念

### 1.4.1 缓冲处理

#### 1.4.1.1 Scatter/gather

### 1.4.2 虚拟内存

### 1.4.3 内存分页

### 1.4.4 文件I/O



# 第四章	选择器（Selector）

​	这一章节我们准备去探索选择器的知识。选择器提供了一种选择就绪态的能力，这种能力使得选择器拥有了多路复用**I/O**。选择就绪态和复用的概念实现了单一线程同时管理多个**I/O**通道。POSIX的操作系统调用方法：select()和poll()已经出现许多年了，大多数其他操作系统都提供了类似的功能，但是直到 JDK1.4版本**I/O**多路复用才正式出现的Java程序员面前。以Java为主的程序员可能之前没遇见过这种**I/O**模型。

​	